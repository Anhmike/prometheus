## update [TradePeriods]
	start_date <- SELECT MAX(TradeEndDate) FROM [RealTransactions]
	end_date <- date(today)
	tradeperiods.df <- create_tradeperiods(start_date, end_date)
	APPEND tradeperiods.df TO [TradePeriods]
	
## update [TradingDays]
	start_date <- SELECT MAX(TradeDayDate) FROM [TradingDays]
	end_date <- date(today)
	trading_days <- gen_trading_days(start_date, end_date)
	trading_days.df <- transpose(trading_days)
	APPEND trading_days.df TO [TradingDays] 
	
## update [MarketPrices]
	start_date <- SELECT MAX(date) FROM [MarketPrices]
	end_date <- SELECT MAX(date) FROM [TradingDays]
	market_prices.df <- get_market_prices(tickers, start_date, end_date)
	APPEND market_prices.df TO [MarketPrices]

## update [FakeTransactions]
	start_date <- SELECT MAX(TranDate) FROM [FakeTransactions]
	end_date <- date(today)
	faketransactions.df <- create_faketransactions(tradeperiods.df, myPortfolioMod, start_date, end_date)
	APPEND faketransactions.df TO [FakeTransactions]

## update [myPortfolioReturns]
	start_date <- SELECT MAX(TranDate) FROM [CashFlows]
	end_date <- date(today)
	my_portfolio_cashflows.df <- gen_portfolio_cashflows([CashFlows], start_date, end_date)
	my_portfolio_cashflow_dates.df <- gen_portfolio_cashflow_dates([CashFlows], start_date, end_date)
	my_portfolio_returns.df <- calc_xirr(my_portfolio_cashflows.df, my_portfolio_cashflow_dates.df)
	APPEND my_portfolio_returns.df TO [myPortfolioReturns]

## calculate discrete performance metrics
	my_portfolio_performance_disc <- calc_performance_disc([myPortfolioReturns])
	[PortfolioPerfDisc] <- my_portfolio_performance_disc
	
## create visuals
## create [benchTransactions] query
## create [benchPortfolio] query
	## user input: which ticker to model, default none
## create [benchPortfolio] cash flow array
## create [benchPortfolio] date array
## calculate returns
	bench_returns <- xirr(bench_cashflow, bench_dates)
## calculate performance metrics
	bench_performance <- calc_performance(bench_returns)
## combine portfolio and benchmark stats
	cp_portfolio_stats
	
monthly_optimization <- function(var1, var2, var3, var4) {
	## generate allocation options
	myallocation <- myallocation(bystep, assets)
	
	## reduce allocation options
	constraints()
	
	## upload options to database
	[allocations] <- replace_table(myallocation)
	
	## calculate ending allocations and apply constraints
	[allocations] <- constraints(mod_allocations([allocations]))
	
	## update stock prices
	last_stock_update <- last_update(var)
	[stock_prices] <- update_stock_prices(last_stock_update, var)
	
	## make trade periods data frame
	tradeperiods.df <- create_tradeperiods(var)
	
	## loop for each scenario
	loop () {
		## create simulation portfolio w/ returns
		simportfolio.df <- simportfolio_constructor([funds], [allocations], tradeperiods, [stock_prices])
		stock_returns <- stock_return(simportfolio.df)
		simportfolio.df <- update_dataframe("simportfolio.df", "returns", stock_returns)
		simportfolio.df <- update_dataframe("simportfolio.df", "universe", {array of "YES"})
		
		## create interfaces for portSim
		data.interface <- create_DataInterface(simportfolio.df)	
		trades.interface <- create_TradesInterface([allocations])
		
		## run portSim and extract period results
		simResult[scenario,] <- portfolioSim(data.interface, trades.interface, tradeperiods.df)
		periodData[scenario,] <- extract_periodData(simResult[scenario])
		
		## calculate continuous performance metrics
		mo_portfolio_stats[scenario,] <- stat_wrapper(periodData[scenario], var)
	}

	## rank scenarios
	mo_ranked_portfolios <- rank(mo_portfolio_stats)
	
	## update tables
	[mo_ranked_portfolios] <- append_to_table("mo_ranked_portfolios", mo_ranked_portfolios)
	[periodData] <- append_to_table("periodData", periodData)
			
	## create visuals
	mo_sumtable <- sumtable(mo_ranked_portfolios, var)
	mo_sumcharts <- sumcharts(mo_ranked_portfolios, var)
	
	## save results
	mo_sumtable_<date>.pdf <- mo_sumtable
	mo_sumcharts_<date>.pdf <- mo_sumcharts
	
	## return results
	return mo_sumtable
	return mo_sumcharts
}